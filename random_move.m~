% Moves the robot in a random direction (including not moving)
function random_move(~,~)       



    % Get Current Figure
    myFigure = gcf;

    [nMovesText, errorObs] = live_gui(myFigure);

    nMoves = 0;

    % Draw Plot Areas
    [ax, ax2] = draw_plot(winW,winH);

    % Read Map
    [mapMatrix, nEmpty] = read_map();

    % Draw Map in figure
    axes(ax);
    mapDrawing = draw_map(myFigure, mapMatrix, ax);        

    % Draw Sensor Indicators
    [sensorU, sensorD, sensorL, sensorR] = draw_sensor(myFigure, ax2, sen); 

    % Hidden Markov Model Parameters
    % Compute Initial Matrix
    [mPi, mapMatrix] = get_initial_distribution(nEmpty, mapMatrix);
    refresh_map(mapMatrix, mapDrawing)

    % Compute Transition Matrix
    %mTrasitionMat = compute_transition();

    % Compute Observations Matrix
    %mObservationMat = compute_observations();

    % Initialize robot
    % Get robot initial position and draw robot
    [mRobotPlot, mRobotPos] = init_robot(myFigure, mapMatrix, ax);

    nSteps = inputdlg('Enter the number of movements of the robot.');

    mTimer = timer('TimerFcn',@(~,~)disp('Timer'), 'StartDelay', 1.5);
    for it= 1:1:str2double(nSteps{1}) 
        % Timer start
        start(mTimer)

        % Check if a move was made or if it tried to hit a wall
        nMovesPast = nMoves;
        while nMoves == nMovesPast
            [nMoves, mRobotPos, mRobotPlot] = move_robot(randi([0 4]), mapMatrix, mRobotPos, mRobotPlot, nMoves, nMovesText, errorObs, OBS_ID);
        end

        % Take Measurements
        [measU, measR, measD, measL] = sense_obstacles(mRobotPos, mapMatrix, sensorU, sensorR, sensorD, sensorL);

        % Update the recursion estimate
        %mapMatrix = update_estimate(mapMatrix, , mTrasitionMat, mObservationMat, measU, measR, measD, measL)

        % Refresh map with probabilities
        refresh_map(mapMatrix, mapDrawing)

        % Wait a bit so that user can see results in map
        wait(mTimer)
    end

    waitforbuttonpress
    cla(ax)
    cla(ax2)

end